<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
    crossorigin="anonymous">
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU"
    rel="stylesheet" />
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<style>
    #parent {
        width: 1000px; 
        height: auto;
        overflow: hidden;
        position: relative;
        background:#f5f5f5;
    }

    #child{
        margin: auto;
    }

    .canvas {
        position: absolute;
    }

    #maskCanvas {
        opacity: 0.5;
    }

    #pic{
        width: 100%;
        height: auto;
    }

    #text {
        width: 1000px;
    }

    .btn:hover {
        text-shadow:0px 0px 1px black;
    }

    .fixed_width {
        width: 130px !important;
    }

    #object_class {
        /* display: none; */
        width: 200px;
        float:right;
    }

    #material_class {
        display: none;
        width: 200px;
        float:right;
    }

    #condition_class {
        display: none;
        width: 200px;
        float:right;
    }

    #text {
        margin-bottom: 20px;
    }

    #buttons {
        margin-top: 20px;
    }

    #contextmenu{
        display:none;
        position:fixed;
        left:0px;
        top:0px;
        width:200px;
        height:180px;
        border:1px solid #000;
        background-color:#fff;
    }
    #contextmenu li{
        user-select: none;
        padding-top: 5px;
        padding-bottom: 5px;
        cursor:pointer;
    }
    #contextmenu ul {
        user-select: none;
        list-style: none;
        padding-left: 20px;
    }
    #edit_label{
        user-select: none;
        border-top:1px solid #f1f6fc;
        border-bottom:1px solid #84b2e0;
    }

    .edit_label_menu{
        user-select: none;
        display: none;
        position: fixed;
        z-index: 1;
        left: 0;
        top: 0;
        height: 100%;
        width: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.5);
    }
    .edit_label_menu_content{
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        user-select: none;
        padding-top: 20px;
        padding-left: 20px;
        padding-bottom: 20px;
        padding-right: 20px;
        background-color: white;
        width: 500px;
        height: 400px;
        margin: auto;
    }

    .current_label{
        user-select: none;
        padding-top: 5px;
        padding-bottom: 5px;
        border-top:1px solid #f1f6fc;
        border-bottom:1px solid #84b2e0;
    }

    #myCanvas{
        user-select: none;
    }

    .hoge{
        color: #FF0000;
    }

</style>

<div id="text" style="display:inline-block;vertical-align:top;">
    <button id="title" type="button" class="btn btn-outline-primary btn-lg">Instructions</button>
    <select id="object_class" class="form-control"></select>
    <select id="material_class" class="form-control"></select>
    <select id="condition_class" class="form-control"></select>
    <ul id="instruction">
        <li>Hold <strong>right click</strong> to draw the image.</li>
        <li><strong>Left click</strong> to draw the segmentation mask of the object.</li>
        <li>Press <strong>CTRL+Z</strong> or click the <strong>Undo</strong> button to undo last deletion/annotation.</li>
        <li>Press <strong>C</strong> to close polygon.</li>
        <li>Click the <strong>Delete</strong> button or press <strong>D</strong> to set detele mode.</li>
        <li>Click the <strong>Annotate</strong> button or press <strong>A</strong> to set annotate mode.</li>
        <li>Click the <strong>Edit</strong> button or press <strong>E</strong> to set edit mode.</li>
        <li>Click the <strong>Undo</strong> button to undo your last deletion/annotation.</li>
        <li>Click the <strong>Reset</strong> button to clear all annotations.</li>
        <li>Click the <strong>Reposition</strong> button to center the image and reset zoom.</li>
        <li>Click the <strong>Submit</strong> button to finish current task.</li>
    </ul>

    <p id="buttons">
        <span id="delete_flip", class="btn-group btn-group-toggle" data-toggle="buttons">
            <label class="btn btn-outline-secondary disabled" type="radio" name="options" id="delete_button" autocomplete="off" checked> Delete </label>
            <label class="btn btn-primary" type="radio" name="options" id="annotate_button" autocomplete="off"> Annotate </label>
            <label class="btn btn-outline-secondary disabled" type="radio" name="options" id="edit_button" autocomplete="off" checked> Edit </label>
        </span>
        <span id="delete_flip", class="btn-group btn-group-toggle" data-toggle="buttons">
            <label class="btn btn-primary" type="radio" name="options" id="object_button" autocomplete="off" checked> Object </label>
            <label class="btn btn-outline-secondary" type="radio" name="options" id="material_button" autocomplete="off"> Material </label>
            <label class="btn btn-outline-secondary" type="radio" name="options" id="condition_button" autocomplete="off" checked> Condition </label>
        </span>
        <input class="btn btn-secondary" id="undo_button" type="button" value = "Undo" />
        <input class="btn btn-danger" id="reset_button" type="button" value = "Reset" />
        <input class="btn btn-warning" id="reposition_button" type="button" value = "Reposition" />
    </p>

    <p>
        <label for="transparency">Transparency percentage</label>
        <input type="range" min="0" max="100" class="range-field my-4 w-25" id="transparency_slider">
    </p>

    <p>
        <label for="masktransparency">Mask Transparency percentage</label>
        <input type="range" min="0" max="100" class="range-field my-4 w-25" id="mask_transparency_slider">
    </p>

    <div>
        <!-- Coordinates input from user -->
        <input id="coordinates" name="coordinates" type="hidden" />
    </div>
</div>

<div id="parent">
    <div id="child">
        <canvas class="canvas" id="maskCanvas"></canvas>
        <canvas class="canvas" id="myCanvas"></canvas>
        <img id="pic" src="${img_url}" />
    </div>
</div>

<div id="contextmenu">
    <ul>
        <li id="edit_label">Edit Label</li>
        <li id="bring_to_front">Bring to Front</li>
        <li id="bring_forward">Bring Forward</li>
        <li id="send_backward">Send Backward</li>
        <li id="send_to_back">Send to Back</li>
    </ul>
</div>

<div class="edit_label_menu", id="object_edit_label_menu">
    <div class="edit_label_menu_content", id="object_edit_label_menu_content">
        <div class="current_label" id="object_current_label">
            Current label : house
        </div>
        <ul class="label_list" id="object_label_list" style="cursor: pointer">
        </ul>
    </div>
</div>

<div class="edit_label_menu", id="material_edit_label_menu">
    <div class="edit_label_menu_content", id="material_edit_label_menu_content">
        <div class="current_label" id="material_current_label">
            Current label : house
        </div>
        <ul class="label_list" id="material_label_list" style="cursor: pointer">
        </ul>
    </div>
</div>

<div class="edit_label_menu", id="condition_edit_label_menu">
    <div class="edit_label_menu_content", id="condition_edit_label_menu_content">
        <div class="current_label" id="condition_current_label">
            Current label : house
        </div>
        <ul class="label_list" id="condition_label_list" style="cursor: pointer">
        </ul>
    </div>
</div>

<script id="turkey" type="text/javascript">
    var translateX, translateY, correctX, correctY;
    var anchorX, anchorY, dragX, dragY, mouseX, mouseY;
    var dragged, dragStart, delta, scaleRatio, scaleDiff;
    var child, parent, canvas, ctx, img;
    var annotations, objectAnnotations, materialAnnotations, conditionAnnotations;
    var objectClassSelection, materialClassSelection, conditionClassSelection;
    var transparency_level = 0.5;
    var dragOffsetX = 0;
    var dragOffsetY = 0;
    var scalingOffsetX = 0;
    var scalingOffsetY = 0;
    var oldScale = 1.0;
    var newScale = 1.0;
    var firstPoint = true;
    var dotSize = 4;
    var scaleTransform = 1;
    var translateTransform = [0, 0];
    var translateTransform_raw = [0, 0];
    var delete_mode = false;
    var current_mode = 1;
    var current_task_mode = 0;
    var polygon_idx = -1;
    var trashcan = new Array();
    var colors = {};
    var timeDownUp = null;
    var rightClick = false;
    var menuOpening;
    var annotationMode;
    const DELETE_MODE = 0;
    const ANNOTATE_MODE = 1;
    const EDIT_MODE = 2;
    const OBJECT_MODE = 0;
    const MATERIAL_MODE = 1;
    const CONDITION_MODE = 2;

    var classes_data = "person-tree-house-road-car-vegetation-ground-static-dynamic";
    var material_classes_data = "asphalt-concrete-metal";
    var condition_classes_data = "dry-wet-icy";
    
    var currentPolygon = { 'class': [] , 'data': [] };

    var start = function () {
        parent = document.getElementById("parent");
        child = document.getElementById("child");
        canvas = document.getElementById("myCanvas");
        maskCanvas = document.getElementById("maskCanvas")
        ctx = canvas.getContext("2d");
        maskctx = maskCanvas.getContext("2d");
        img = document.getElementById("pic");
        object_label_list = document.getElementById("object_label_list");
        material_label_list = document.getElementById("material_label_list");
        condition_label_list = document.getElementById("condition_label_list");

        canvas.width = img.width;
        canvas.height = img.height;
        canvas.style.cursor = "crosshair";
        maskCanvas.width = img.width;
        maskCanvas.height = img.height;
        maskCanvas.style.cursor = "crosshair";
        
        $('#instruction').slideUp(1000);

        $('#title').click(function () {
            $('#instruction').clearQueue();
            $('#instruction').slideToggle();
        });

        annotations_str = "${annotations}"
        if (annotations_str == ("$" + "{annotations}")){
            annotations = [];
        } else {
            annotations = [];
            // annotations_str = annotations_str.replace(/'/g, '"');
            // annotations_str = annotations_str.replace(/;/g, ',');
            // annotations = JSON.parse(annotations_str);
            // annotationsChanged();
        }

        objectAnnotations = [];
        materialAnnotations = [];
        conditionAnnotations = [];
        
        function push(obj) {
            Array.prototype.push.call(this, obj);
            annotationsChanged();
        }
        
        function splice(...args) {
            switch (args.length) {
                case 1:
                    Array.prototype.splice.call(this, args[0]);
                    break;
                case 2:
                    Array.prototype.splice.call(this, args[0], args[1]);
                    break;
                case 3:
                    Array.prototype.splice.call(this, args[0], args[1], args[2]);
            }
            annotationsChanged();
        }

        function moveElement(src, dst){
            if (src === dst || src > this.length -1 || dst > this.length - 1) {
                return;
            }
            const value = this[src];
            const tail = this.slice(src + 1);
            this.splice(src);
            Array.prototype.push.apply(this, tail);
            this.splice(dst, 0, value);
        }

        annotations.push = push;
        annotations.splice = splice;
        annotations.moveElement = moveElement;
        // objectAnnotations.push = push;
        // objectAnnotations.splice = splice;
        // objectAnnotations.moveElement = moveElement;
        // materialAnnotations.push = push;
        // materialAnnotations.splice = splice;
        // materialAnnotations.moveElement = moveElement;
        // conditionAnnotations.push = push;
        // conditionAnnotations.splice = splice;
        // conditionAnnotations.moveElement = moveElement;

        annotations.push = function(obj) {
            Array.prototype.push.call(annotations, obj);
            annotationsChanged();
        }

        annotations.splice = function(...args) {
            switch (args.length) {
                case 1:
                    Array.prototype.splice.call(annotations, args[0]);
                    break;
                case 2:
                    Array.prototype.splice.call(annotations, args[0], args[1]);
                    break;
                case 3:
                    Array.prototype.splice.call(annotations, args[0], args[1], args[2]);
            }
            annotationsChanged();
        }

        annotations.moveElement = function(src, dst){
            if (src === dst || src > annotations.length -1 || dst > annotations.length - 1) {
                return;
            }
            const value = annotations[src];
            const tail = annotations.slice(src + 1);
            annotations.splice(src);
            Array.prototype.push.apply(annotations, tail);
            annotations.splice(dst, 0, value);
        }

        // object class initialization
        {
            objectClassSelection = document.getElementById("object_class");
            classes = classes_data.split('-');

            // populate list items and generate unique colors based on string hash
            var hueCount = 0;
            var classesLength = classes.length;
            classes.forEach((theClass) => {
                var option = document.createElement("option");
                // var hue = Math.abs(theClass.hashCode() % 360) / 360;
                var hue = hueCount/classesLength
                hueCount++;
                var color = [hue, 1.0, 1.0];
                option.innerHTML = theClass;
                option.style.background = HSVtoRGBstring(hue,1,1);
                option.style.color = blackOrWhite(HSVtoRGBstring(hue,1,1));
                objectClassSelection.appendChild(option);
                colors[theClass] = color;

                var newLi = document.createElement("li");
                newLi.id = theClass;
                newLi.innerHTML = theClass;
                object_label_list.appendChild(newLi);
                document.getElementById(theClass).onclick = function(){
                    annotations[polygon_idx].class = theClass;
                    document.getElementById('object_edit_label_menu').style.display="none";
                    updateGraphics();
                }
            });
            objectClassSelection.size = Math.min(10, classes.length);
            objectClassSelection.selectedIndex = 0;
            updateGraphics();
        }

        // material class initialization
        {
            materialClassSelection = document.getElementById("material_class");
            materialClasses = material_classes_data.split('-');

            // populate list items and generate unique colors based on string hash
            var hueCount = 0;
            var classesLength = materialClasses.length;
            materialClasses.forEach((theClass) => {
                var option = document.createElement("option");
                // var hue = Math.abs(theClass.hashCode() % 360) / 360;
                var hue = hueCount/classesLength
                hueCount++;
                var color = [hue, 1.0, 1.0];
                option.innerHTML = theClass;
                option.style.background = HSVtoRGBstring(hue,1,1);
                option.style.color = blackOrWhite(HSVtoRGBstring(hue,1,1));
                materialClassSelection.appendChild(option);
                colors[theClass] = color;

                var newLi = document.createElement("li");
                newLi.id = theClass;
                newLi.innerHTML = theClass;
                material_label_list.appendChild(newLi);
                document.getElementById(theClass).onclick = function(){
                    annotations[polygon_idx].class = theClass;
                    document.getElementById('material_edit_label_menu').style.display="none";
                    updateGraphics();
                }
            });

            materialClassSelection.size = Math.min(10, materialClasses.length);
            materialClassSelection.selectedIndex = 0;
            updateGraphics();
        }

        // condition class initialization
        {
            conditionClassSelection = document.getElementById("condition_class");
            conditionClasses = condition_classes_data.split('-');

            // populate list items and generate unique colors based on string hash
            var hueCount = 0;
            var classesLength = conditionClasses.length;
            conditionClasses.forEach((theClass) => {
                var option = document.createElement("option");
                // var hue = Math.abs(theClass.hashCode() % 360) / 360;
                var hue = hueCount/classesLength
                hueCount++;
                var color = [hue, 1.0, 1.0];
                option.innerHTML = theClass;
                option.style.background = HSVtoRGBstring(hue,1,1);
                option.style.color = blackOrWhite(HSVtoRGBstring(hue,1,1));
                conditionClassSelection.appendChild(option);
                colors[theClass] = color;

                var newLi = document.createElement("li");
                newLi.id = theClass;
                newLi.innerHTML = theClass;
                condition_label_list.appendChild(newLi);
                document.getElementById(theClass).onclick = function(){
                    annotations[polygon_idx].class = theClass;
                    document.getElementById('condition_edit_label_menu').style.display="none";
                    updateGraphics();
                }
            });

            conditionClassSelection.size = Math.min(10, conditionClasses.length);
            conditionClassSelection.selectedIndex = 0;
            updateGraphics();
        }

        //initialize slider
        var slider = document.getElementById('transparency_slider')
        slider.oninput = function() {
            transparency_level = this.value / 100.0;
            updateGraphics();
        };
        
        var maskslider = document.getElementById('mask_transparency_slider')
        maskslider.oninput = function() {
            mask_transparency_level = this.value / 100.0;
            maskCanvas.style.opacity = mask_transparency_level;
        };

        //initialize buttons
        $("#reset_button"     ).click(reset);
        $("#reposition_button").click(reposition);
        $("#undo_button"      ).click(undo);
        $("#delete_button"    ).click(setDelete);
        $("#annotate_button"  ).click(setAnnotate);
        $("#edit_button"      ).click(setEdit);
        $("#object_button"    ).click(setObjectMode);
        $("#material_button"  ).click(setMaterialMode);
        $("#condition_button" ).click(setConditionMode);

        document.getElementById("submitButton").disabled = false;
        document.getElementById("buttons").appendChild(document.getElementById("submitButton"));

        child.addEventListener('DOMMouseScroll', handleScroll, false);
        child.addEventListener('mousewheel', handleScroll, false);

        function scroll_control(event) {
           event.preventDefault();
        }
        child.addEventListener('mousewheel', scroll_control, false); //canvas内スクロールを無効化


        // disable right click context menu on canvas
        canvas.oncontextmenu = function ()
        {
            return false;
        }

        canvas.addEventListener('mouseout', function(evt) {
            dragStart = false;
            dragged = false; 
        });

        canvas.addEventListener('pointerdown', function (evt) {
            if (menuOpening) {
                return;
            }
            rightClick = evt.which == 3;
            getCorrectCoords(evt);
            timeDownUp = new Date().getTime();
            anchorX = evt.clientX;
            anchorY = evt.clientY;
            dragged = false;
            dragStart = true;
        });

        canvas.addEventListener('pointerup', function (evt) {
            if (menuOpening){
                menuOpening = false;
                document.getElementById('contextmenu').style.display="none";
                return;
            }
            timeDownUp = new Date().getTime();
            getCorrectCoords(evt);
            if (!rightClick){
                switch (getCurrentMode()){
                    case DELETE_MODE:
                        deleteAnnotation();
                        break;
                    case ANNOTATE_MODE:
                        updateAnnotation();
                        break;
                    case EDIT_MODE:
                        editAnnotation(evt);
                        break;
                }
            }
            rightClick = false;
            dragStart = false;
            updateGraphics();

            if (annotations.length == 0) {
                document.getElementById('coordinates').value = '';
            } else {
                document.getElementById('coordinates').value = JSON.stringify(annotations);
            }
        });

        canvas.addEventListener('mousemove', function (evt) {
            if (menuOpening){
                return;
            }
            getCorrectCoords(evt);
            if (getCurrentMode() == DELETE_MODE || getCurrentMode() == EDIT_MODE) {
                polygon_idx = getPolygonIdx();
                updateGraphics();
            } else if (rightClick) {
                var timeMove = new Date().getTime();
                if (timeMove > timeDownUp) {
                    if (dragStart) {
                        dragged = true;
                        dragX = evt.clientX - anchorX;
                        dragY = evt.clientY - anchorY;
                        translateTransform_raw = [translateTransform_raw[0] + dragX, translateTransform_raw[1] + dragY];
                        translateTransform[0] = translateTransform_raw[0] / newScale;
                        translateTransform[1] = translateTransform_raw[1] / newScale;
                        updateTransform();
                        dragOffsetX += dragX;
                        dragOffsetY += dragY;
                        anchorX = evt.clientX;
                        anchorY = evt.clientY;
                    }
                } else {
                    timeDownUp = null;
                }
            } else {
                updateGraphics()
            }
        });

        function editAnnotation(evt){
            if (typeof polygon_idx === "undefined") return;
            menuOpening = true;  
            document.getElementById('contextmenu').style.left=evt.clientX+"px";
            document.getElementById('contextmenu').style.top=evt.clientY+"px";
            document.getElementById('contextmenu').style.display="block";
        }

        document.getElementById("edit_label").onclick = function(){
            menuOpening = false;
            switch (current_task_mode){
                case OBJECT_MODE:
                    document.getElementById("object_current_label").innerHTML = `Current label : ${annotations[polygon_idx].class}`;
                    document.getElementById('contextmenu').style.display="none";
                    document.getElementById('object_edit_label_menu').style.display="block";
                    break;
                case MATERIAL_MODE:
                    document.getElementById("material_current_label").innerHTML = `Current label : ${annotations[polygon_idx].class}`;
                    document.getElementById('contextmenu').style.display="none";
                    document.getElementById('material_edit_label_menu').style.display="block";
                    break;
                case CONDITION_MODE:
                    document.getElementById("condition_current_label").innerHTML = `Current label : ${annotations[polygon_idx].class}`;
                    document.getElementById('contextmenu').style.display="none";
                    document.getElementById('condition_edit_label_menu').style.display="block";
                    break;
            }

        }

        document.getElementById("bring_to_front").onclick = function(){
            menuOpening = false;
            annotations.moveElement(polygon_idx,annotations.length -1);
            document.getElementById('contextmenu').style.display="none";
            updateGraphics()
        }

        document.getElementById("bring_forward").onclick = function(){
            menuOpening = false;
            annotations.moveElement(polygon_idx, polygon_idx+1);
            document.getElementById('contextmenu').style.display="none";
            updateGraphics()
        }

        document.getElementById("send_backward").onclick = function(){
            menuOpening = false;
            annotations.moveElement(polygon_idx, polygon_idx-1);
            document.getElementById('contextmenu').style.display="none";
            updateGraphics()
        }

        document.getElementById("send_to_back").onclick = function(){
            menuOpening = false;
            annotations.moveElement(polygon_idx, 0);
            document.getElementById('contextmenu').style.display="none";
            updateGraphics()
        }

        function drawPolygonOutline(corners) {
            for (var j = 0; j < corners.length; j++) {
                ctx.fillRect(corners[j][0] - dotSize / 2, corners[j][1] - dotSize / 2, dotSize, dotSize);
            }
            ctx.beginPath();
            ctx.moveTo(corners[0][0], corners[0][1]);
            for (var j = 1; j < corners.length; j++) {
                ctx.lineTo(corners[j][0], corners[j][1]);
                ctx.stroke();
            }
            ctx.lineTo(correctX, correctY);
            ctx.stroke();
            ctx.closePath();
        }

        function fillPolygon(corners) {
            ctx.beginPath();
            ctx.moveTo(corners[0][0], corners[0][1]);
            for (var j = 1; j < corners.length; j++) {
                ctx.lineTo(corners[j][0], corners[j][1]);
                ctx.stroke();
            }
            ctx.lineTo(corners[0][0], corners[0][1]);
            ctx.stroke();
            ctx.closePath();
            ctx.fill();
        }

        function fillPolygon2(corners) {
            maskctx.globalCompositeOperation = 'source-over';
            maskctx.beginPath();
            maskctx.moveTo(corners[0][0], corners[0][1]);
            for (var j = 1; j < corners.length; j++) {
                maskctx.lineTo(corners[j][0], corners[j][1]);
                maskctx.stroke();
            }
            maskctx.lineTo(corners[0][0], corners[0][1]);
            maskctx.stroke();
            maskctx.closePath();
            maskctx.fill();
        }

        function cutPolygon2(corners) {
            maskctx.globalCompositeOperation = 'destination-out';
            maskctx.beginPath();
            maskctx.moveTo(corners[0][0], corners[0][1]);
            for (var j = 1; j < corners.length; j++) {
                maskctx.lineTo(corners[j][0], corners[j][1]);
                maskctx.stroke();
            }
            maskctx.lineTo(corners[0][0], corners[0][1]);
            maskctx.stroke();
            maskctx.closePath();
            maskctx.fill();
        }

        function clearCurrentAnn() {
            currentPolygon.data = new Array();
        }

        function deleteAnnotation() {
            if (polygon_idx > -1) {
                var ann_copy = deep_copy(annotations[polygon_idx]);
                trashcan.push(ann_copy);
                annotations.splice(polygon_idx, 1);
                polygon_idx = getPolygonIdx();
                if(annotations.length == 0)
                    // no more to delete, go back to annotate mode
                    setAnnotate();
            }
            annotationsChanged();
        }

        function setDelete () {
            setMode(DELETE_MODE);
        }

        function setAnnotate() {
            setMode(ANNOTATE_MODE);
        }

        function setEdit() {
            setMode(EDIT_MODE);
        }

        function getCurrentMode() {
            return current_mode;
        }

        function setDeleteMode(deleteMode) {
            if( deleteMode == true && $("#delete_button").hasClass("disabled"))
            {
                return;
            }
            
            delete_mode = deleteMode;
            if (delete_mode == false) {
                // annotate mode
                canvas.style.cursor = "crosshair";
                $("#delete_button").removeClass('btn-primary');
                $("#delete_button").addClass('btn-outline-secondary');

                $("#annotate_button").removeClass('btn-outline-secondary');
                $("#annotate_button").addClass('btn-primary');
                updateGraphics();
            } else {
                // delete mode
                polygon_idx = getPolygonIdx();
                canvas.style.cursor = "pointer";
                $("#annotate_button").removeClass('btn-primary');
                $("#annotate_button").addClass('btn-outline-secondary');

                $("#delete_button").removeClass('btn-outline-secondary');
                $("#delete_button").addClass('btn-primary');
                updateGraphics();
            }
        }

        function setMode(mode) {
            menuOpening = false;
            document.getElementById('contextmenu').style.display="none";
            if (mode == DELETE_MODE) {
                if( $("#delete_button").hasClass("disabled")) return;
                currentPolygon = { 'class': [], 'data': [] };
                current_mode = mode;
                // delete mode
                polygon_idx = getPolygonIdx();
                canvas.style.cursor = "pointer";
                $("#annotate_button").removeClass('btn-primary');
                $("#annotate_button").addClass('btn-outline-secondary');
                $("#edit_button").removeClass('btn-primary');
                $("#edit_button").addClass('btn-outline-secondary');

                $("#delete_button").removeClass('btn-outline-secondary');
                $("#delete_button").addClass('btn-primary');
                updateGraphics();
            } else if (mode == ANNOTATE_MODE) {
                current_mode = mode;
                // annotate mode
                canvas.style.cursor = "crosshair";
                $("#delete_button").removeClass('btn-primary');
                $("#delete_button").addClass('btn-outline-secondary');
                $("#edit_button").removeClass('btn-primary');
                $("#edit_button").addClass('btn-outline-secondary');

                $("#annotate_button").removeClass('btn-outline-secondary');
                $("#annotate_button").addClass('btn-primary');
                updateGraphics();
            } else {
                if( $("#edit_button").hasClass("disabled")) return;
                currentPolygon = { 'class': [], 'data': [] };
                current_mode = mode;
                // edit mode
                canvas.style.cursor = "pointer";
                $("#delete_button").removeClass('btn-primary');
                $("#delete_button").addClass('btn-outline-secondary');
                $("#annotate_button").removeClass('btn-primary');
                $("#annotate_button").addClass('btn-outline-secondary');

                $("#edit_button").removeClass('btn-outline-secondary');
                $("#edit_button").addClass('btn-primary');
                updateGraphics();
            }
        }

        function setObjectMode() {
            setTaskMode(OBJECT_MODE);
        }

        function setMaterialMode() {
            setTaskMode(MATERIAL_MODE);
        }

        function setConditionMode() {
            setTaskMode(CONDITION_MODE);
        }

        function setTaskMode(mode) {
            currentPolygon = { 'class': [], 'data': [] };
            menuOpening = false;
            document.getElementById('contextmenu').style.display="none";
            switch (current_task_mode){
                case OBJECT_MODE:
                    objectAnnotations = annotations;
                    break;
                case MATERIAL_MODE:
                    materialAnnotations = annotations;
                    break
                case CONDITION_MODE:
                    conditionAnnotations = annotations;
                    break;
            }
            if (mode == OBJECT_MODE) {
                current_task_mode = mode;
                // delete mode
                $("#material_button").removeClass('btn-primary');
                $("#material_button").addClass('btn-outline-secondary');
                materialClassSelection.style.display = "none";
                $("#condition_button").removeClass('btn-primary');
                $("#condition_button").addClass('btn-outline-secondary');
                conditionClassSelection.style.display = "none";

                $("#object_button").removeClass('btn-outline-secondary');
                $("#object_button").addClass('btn-primary');
                objectClassSelection.style.display = "block";
                annotations = objectAnnotations;

                if(annotations.length == 0) setAnnotate();
                annotationsChanged();
                updateGraphics();
            } else if (mode == MATERIAL_MODE) {
                current_task_mode = mode;
                $("#object_button").removeClass('btn-primary');
                $("#object_button").addClass('btn-outline-secondary');
                objectClassSelection.style.display = "none";
                $("#condition_button").removeClass('btn-primary');
                $("#condition_button").addClass('btn-outline-secondary');
                conditionClassSelection.style.display = "none";

                $("#material_button").removeClass('btn-outline-secondary');
                $("#material_button").addClass('btn-primary');
                materialClassSelection.style.display = "block";
                annotations = materialAnnotations;

                if(annotations.length == 0) setAnnotate();
                annotationsChanged();
                updateGraphics();
            } else {
                current_task_mode = mode;
                $("#object_button").removeClass('btn-primary');
                $("#object_button").addClass('btn-outline-secondary');
                objectClassSelection.style.display = "none";
                $("#material_button").removeClass('btn-primary');
                $("#material_button").addClass('btn-outline-secondary');
                materialClassSelection.style.display = "none";

                $("#condition_button").removeClass('btn-outline-secondary');
                $("#condition_button").addClass('btn-primary');
                conditionClassSelection.style.display = "block";
                annotations = conditionAnnotations;

                if(annotations.length == 0) setAnnotate();
                annotationsChanged();
                updateGraphics();
            }
        }

        function reset() {
            var result = window.confirm("Do you really want to reset?");
            if (!result) return;
            clearAnnotations();
            reposition();
            firstPoint = true;
            dragStart = false;
            dragged = false;
            setMode(ANNOTATE_MODE);
        }

        function reposition() {
            child.style.transform = "";
            scaleTransform = 1.0;
            translateTransform = [0, 0];
            translateTransform_raw = [0, 0];
            newScale = 1.0;
            oldScale = 1.0;
            scaleRatio = 1.0;
            scaleDiff = 0;
            dragOffsetX = 0;
            dragOffsetY = 0;
            scalingOffsetX = 0;
            scalingOffsetY = 0;
        }

        function updateAnnotation() {
            currentPolygon.class = getClass();
            currentPolygon.data.push([correctX, correctY]);
        }

        function clearAnnotations() {
            annotations = new Array();
            trashcan = new Array();
            currentPolygon = { 'class': [], 'data': [] };
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function getClass() {
            if (current_task_mode == OBJECT_MODE) return objectClassSelection[objectClassSelection.selectedIndex].innerHTML;
            else if (current_task_mode == MATERIAL_MODE) return materialClassSelection[materialClassSelection.selectedIndex].innerHTML;
            else return conditionClassSelection[conditionClassSelection.selectedIndex].innerHTML;
        }

        // Redraw all annotations
        function updateGraphics() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            maskctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            for (var i = 0; i < annotations.length; i++) {
                var ann = annotations[i];
                var corners = ann.data;
                var r, g, b;
                if ((getCurrentMode() == DELETE_MODE || getCurrentMode() == EDIT_MODE) && polygon_idx == i) {
                    r = g = b = 0.5;
                } else {
                    [r, g, b] = getColor(ann);
                }

                // draw complete polygons
                ctx.fillStyle   = "rgba(" + r + "," + g + "," + b + ", " + transparency_level + ")";
                ctx.strokeStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                fillPolygon(corners);
            }
            // draw current polygon
            if (currentPolygon.data.length != 0) {
                var r, g, b;
                [r, g, b] = getColor(currentPolygon);
                ctx.fillStyle   = "rgba(" + r + "," + g + "," + b + ", " + transparency_level + ")";
                ctx.strokeStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                var corners = currentPolygon.data;
                drawPolygonOutline(corners);
            }
            if (current_task_mode != OBJECT_MODE) drawMask();
        }

        function drawMask() {
            maskctx.clearRect(0, 0, canvas.width, canvas.height);
            var targetClasses = ["road","ground"]; 
            for (var i = 0; i < objectAnnotations.length; i++) {
                var ann = objectAnnotations[i];                
                var corners = ann.data;
                var r, g, b;
                r = g = b = 0.5;
                // draw complete polygons
                maskctx.fillStyle   = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                maskctx.strokeStyle = "rgba(" + r + "," + g + "," + b + ", 1.0)";
                if (targetClasses.indexOf(ann.class)<0) fillPolygon2(corners);
                else cutPolygon2(corners);
            }
        }

        // depending on mode, either undo deletion or undo annotation
        function undo() {
            if (getCurrentMode() == DELETE_MODE){
                if (trashcan.length > 0) {
                    annotations.push(trashcan.pop());
                }
            } else {
                if (currentPolygon.data.length == 0) {
                    annotations.pop();
                } else {
                    console.log(currentPolygon);
                    currentPolygon.data.pop();
                    console.log(currentPolygon);
                }
            }
            if(annotations.length == 0){
                // no more to delete, go back to annotate mode
                setAnnotate();
            }
            annotationsChanged();
            updateGraphics();
        }


        document.getElementById("object_edit_label_menu").addEventListener("click", function(){
            document.getElementById('object_edit_label_menu').style.display="none";
        })

        document.getElementById("object_edit_label_menu_content").addEventListener("click", function(evt){
            evt.stopPropagation();
        })

        document.getElementById("material_edit_label_menu").addEventListener("click", function(){
            document.getElementById('material_edit_label_menu').style.display="none";
        })

        document.getElementById("material_edit_label_menu_content").addEventListener("click", function(evt){
            evt.stopPropagation();
        })
        
        document.getElementById("condition_edit_label_menu").addEventListener("click", function(){
            document.getElementById('condition_edit_label_menu').style.display="none";
        })

        document.getElementById("condition_edit_label_menu_content").addEventListener("click", function(evt){
            evt.stopPropagation();
        })

        window.addEventListener("keydown", function (evt) {
            // Press ctrl + Z for "Undo"
            if ((evt.key == 'z') && (evt.ctrlKey)) {
                undo();
            }

            // Press D for "Delete"
            if ((evt.key == 'd')) {
                setDelete();
            }

            // Press A for "Annotate"
            if ((evt.key == 'a')) {
                setAnnotate();
            }

            // Press E for "Edit"
            if ((evt.key == 'e')) {
                setEdit();
            }

            // if ((evt.key == 't')) { // for test
            //     drawMask();
            // }

            // Press C for "Close Polygon"
            if (evt.key == 'c') {
                if (currentPolygon.data.length > 2) {
                    currentPolygon.class = getClass();
                    annotations.push(Object.assign({}, currentPolygon));
                    switch (current_task_mode){
                        case OBJECT_MODE:
                            objectAnnotations = annotations;
                            break;
                        case MATERIAL_MODE:
                            materialAnnotations = annotations;
                            break;
                        case CONDITION_MODE:
                            conditionAnnotations = annotations;
                            break;
                    }
                    currentPolygon.data = new Array();
                }
                // Update coordinates
                var objectJsonString, materialJsonString, conditionJsonString;
                objectAnnotations.length    == 0 ? objectJsonString    = '' : objectJsonString    = JSON.stringify(objectAnnotations);
                materialAnnotations.length  == 0 ? materialJsonString  = '' : materialJsonString  = JSON.stringify(materialAnnotations);
                conditionAnnotations.length == 0 ? conditionJsonString = '' : conditionJsonString = JSON.stringify(conditionAnnotations);
                document.getElementById('coordinates').value = objectJsonString + materialJsonString + conditionJsonString;
                // if (annotations.length == 0) {
                //     document.getElementById('coordinates').value = '';
                // } else {
                //     document.getElementById('coordinates').value = JSON.stringify(annotations);
                // }
            }
            updateGraphics();
        }, true);
    }

    window.onload = function () {
        start();
    }

    var handleScroll = function (evt) {
        getCorrectCoords(evt);
        delta = evt.wheelDelta ? evt.wheelDelta / 40 : evt.detail ? -evt.detail : 0;

        newScale += delta / 10;
        newScale = Math.max(newScale, 1.0);
        newScale = Math.min(newScale, 5.0);
        scaleRatio = newScale / oldScale;
        scaleDiff = newScale - oldScale;
        oldScale = scaleTransform = newScale;

        scalingOffsetX = (newScale - 1) * parent.offsetWidth / 2;
        scalingOffsetY = (newScale - 1) * parent.offsetHeight / 2;

        translateTransform_raw[0] -= (correctX - parent.offsetWidth / 2) * scaleDiff;
        translateTransform_raw[1] -= (correctY - parent.offsetHeight / 2) * scaleDiff;

        translateTransform[0] = translateTransform_raw[0] / newScale;
        translateTransform[1] = translateTransform_raw[1] / newScale;
        updateTransform();
    };

    function updateTransform() {
        child.style.transform = "";
        child.style.transform += 'scale(' + scaleTransform + ', ' + scaleTransform + ')';
        child.style.transform += 'translate(' + translateTransform[0] + 'px, ' + translateTransform[1] + 'px)';
    }

    function getCorrectCoords(evt) {
        mouseX = evt.clientX - parent.offsetLeft + parent.scrollLeft + window.pageXOffset;
        mouseY = evt.clientY - parent.offsetTop + parent.scrollTop + window.pageYOffset;
        correctX = (mouseX + scalingOffsetX - translateTransform_raw[0]) / newScale;
        correctY = (mouseY + scalingOffsetY - translateTransform_raw[1]) / newScale;
        correctX = Math.round(correctX);
        correctY = Math.round(correctY);
    }

    function getPolygonIdx(){
        for (var i = annotations.length - 1; i >= 0; i--) {
            if (pointInPolygon(correctX, correctY, annotations[i].data)){
                return i;
            }
        }
    }

    function deep_copy(obj){
        return jQuery.extend(true, {}, obj);
    }

    var annotationsChanged = function(){
        if(annotations.length == 0)
        {
            $("#delete_button").addClass("disabled");
            $("#edit_button").addClass("disabled");
        } else {
            $("#delete_button").removeClass("disabled");
            $("#edit_button").removeClass("disabled");
        }
    }

    function pointInPolygon(correctX, correctY, corners) {
        var windingNumber = 0, x = correctX, y = correctY;
        var i = corners.length-1; // indexLast(corners)
        for (var j = 0, yi, yj, counterClockwise ; i >= 0; j = i--) {
            yi=corners[i][1]-y; yj=corners[j][1]-y;
            if ((yi>0)!=(yj>0)
                && (counterClockwise=(yj>yi))
                    ==(yj*(corners[i][0]-x)>yi*(corners[j][0]-x)))
            windingNumber+=counterClockwise?1:-1;
        }
        return windingNumber!==0;
    }

    String.prototype.hashCode = function () {
        var hash = 0;
        if (this.length == 0) {
            return hash;
        }
        for (var i = 0; i < this.length; i++) {
            var char = this.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash;
    }

    function HSVtoRGB(h, s, v) {
        // Borrowed from https://stackoverflow.com/a/17243070/4970438
        var r, g, b, i, f, p, q, t;
        if (arguments.length === 1) {
            s = h.s, v = h.v, h = h.h;
        }
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v, g = t, b = p; break;
            case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break;
            case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break;
            case 5: r = v, g = p, b = q; break;
        }
        return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
        };
    }

    function toHex(v) {
       return (('00' + v.toString(16).toUpperCase()).substr(-2));
    }

    function HSVtoRGBstring(h, s, v) {
        var rgbColors = HSVtoRGB(h, s, v);
        var r = rgbColors.r;
        var g = rgbColors.g;
        var b = rgbColors.b;
        return "#"+toHex(r)+toHex(g)+toHex(b);
    }

    function blackOrWhite ( hexcolor ) {
	    var r = parseInt( hexcolor.substr( 1, 2 ), 16 ) ;
	    var g = parseInt( hexcolor.substr( 3, 2 ), 16 ) ;
	    var b = parseInt( hexcolor.substr( 5, 2 ), 16 ) ;

	    return ( ( ( (r * 299) + (g * 587) + (b * 114) ) / 1000 ) < 128 ) ? "white" : "black" ;
    }

    function getColor(ann){
        var color = colors[ann.class];
        var h = color[0];
        var s = color[1];
        var v = color[2];
        var rgbColors = HSVtoRGB(h, s, v);
        var r = rgbColors.r.toString();
        var g = rgbColors.g.toString();
        var b = rgbColors.b.toString();
        return [r, g, b]
    }

</script>